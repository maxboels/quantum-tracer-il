# FTX Tracer Tr### 1.1 Tapped Signal Lines

Three essential control signals are tapped from the integrated ESC/Receiver board (FTX9731):

| Signal Name | Purpose / Function |
|-------------|-------------------|
| **PWM Drive (Throttle)** | Motor Control. High-frequency signal (≈985 Hz) controlled by Duty Cycle (0%→70%) |
| **PWM Servo (Steering)** | Steering Control. Standard RC signal (≈47 Hz) controlled by Pulse Width (1065μs→1959μs) |
| **GND (Ground)** | Common Reference. Must be connected to the Raspberry Pi's GND |n### 1.2 Logic Level Converter

⚠️ **Required for GPIO protection.** The car's 5V signals must be converted to 3.3V for safe Raspberry Pi operation.

- **HV Side:** Connect to car's PWM signals and ground
- **LV Side:** Connect to Raspberry Pi GPIO pins (BCM18 & 23) and ground
- **Ground:** Connect all ground references togetherct: Raspberry Pi Implementation ### 2.2 GPIO Pin Mapping

| Signal | BCM Pin |
|--------|---------|
| **Steering (PWM Servo)** | BCM 18 |
| **Throttle (PWM Drive)** | BCM 23 |his document outlines the hardware connections, verified signal parameters, and the software execution steps required to use your Raspberry Pi for both expert data capture and autonomous control of the FTX Tracer Truggy.

## Table of Contents

- [Hardware Overview and Signal Tapping](#hardware-overview-and-signal-tapping)
- [Raspberry Pi Software Setup](#raspberry-pi-software-setup)
- [Phase I: Data Logging](#phase-i-data-logging-reading-expert-commands)
- [Phase II: Autonomous Control](#phase-ii-autonomous-control-writing-commands)

## Hardware Overview and Signal Tapping

The core of this project relies on successfully intercepting the low-voltage control signals generated by the car's integrated ESC/Receiver board (FTX9731).

### 1.1 Tapped Signal Lines (The Three Critical Connections)

We identified three essential points on the integrated circuit, which you have successfully soldered:

| Signal Name | Physical Location | Purpose / Function |
|-------------|-------------------|-------------------|
| **PWM Drive (Throttle)** | Wire soldered to the main bus/trace near the large capacitor and MOSFETs | Motor Control. High-frequency signal (≈985 Hz) controlled by Duty Cycle (0%→70%) |
| **PWM Servo (Steering)** | Wire soldered near the servo driver chip (often close to the steering servo connector) | Steering Control. Standard RC signal (≈47 Hz) controlled by Pulse Width (1065μs→1959μs) |
| **GND (Ground)** | Tapped from the black wire/pin on the steering servo connector or a chassis point | Common Reference. Must be connected to the Raspberry Pi's GND |

### 1.2 Essential Safety Component: Logic Level Converter

⚠️ **This step is non-negotiable for protecting your Raspberry Pi.** The control signals from the car are likely 5V logic, while the Raspberry Pi's GPIO pins are only 3.3V-tolerant.

| Converter Side | Connects to... | Purpose |
|---------------|----------------|---------|
| **HV (High Voltage, 5V)** | → Car's PWM Drive tap<br>→ Car's PWM Servo tap | Signal conversion from 5V to 3.3V |
| **LV (Low Voltage, 3.3V)** | → Raspberry Pi GPIO Pins (BCM18 & 23) | Signal Input/Output at RPi's safe voltage level |
| **GND** | → Car's GND<br>→ RPi's GND | Common ground reference |

### 1.3 Verified Signal Parameters

Your oscilloscope analysis provided the precise control values, which are hardcoded into the Python script for accurate recording and control:

| Parameter | Steering (PWM Servo) | Throttle (PWM Drive) |
|-----------|---------------------|---------------------|
| **Frequency** | 47 Hz | 985 Hz |
| **Neutral/Stop** | 1491μs (≈7.0% Duty) | 0% Duty Cycle |
| **Full Range** | 1065μs→1959μs | 0%→70% Duty Cycle |

## Raspberry Pi Software Setup and Prerequisites

Before running the control script, ensure your Raspberry Pi is configured for high-performance PWM access.

### 2.1 Install and Start the pigpio Daemon

The pigpio daemon runs in the background and handles the microsecond-accurate timing required to read and write PWM signals, bypassing the latency of the Python interpreter.

**Install the pigpio Library:**
```bash
sudo apt update
sudo apt install pigpio python3-pigpio
```

**Start the pigpio Service (Daemon):**
```bash
sudo pigpiod
```

> **Note:** This command must be executed every time you restart your RPi before running the control script.

### 2.2 GPIO Pin Mapping

The Python script uses the BCM (Broadcom) pin numbering scheme. Ensure your Level Converter's 3.3V outputs are wired to these physical pins:

| Signal | BCM Pin (in script) | Physical Pin |
|--------|-------------------|--------------|
| **Steering (PWM Servo)** | BCM 18 | Physical Pin 12 |
| **Throttle (PWM Drive)** | BCM 23 | Physical Pin 16 |

## Phase I: Data Logging (Reading Expert Commands)

This phase uses the `RCReader` class to passively "eavesdrop" on the PWM signals created by the human driver via the RC transmitter.

### 3.1 Principle of Reading

The `RCReader` class uses pigpio callbacks, which are hardware interrupts that trigger precisely when the signal changes (rising edge →HIGH, falling edge →LOW).

- **Steering:** We calculate the HIGH pulse duration in μs
- **Throttle:** We calculate the Duty Cycle (Pulse Width/Period) in percent
- **Normalization:** The `get_normalized_action()` method converts these raw values into ML-friendly actions (Steering ∈[−1.0,1.0], Throttle ∈[0.0,1.0])

### 3.2 Execution

**Integrated Data Collection (Recommended):**
```bash
python3 src/record/integrated_data_collector.py --episode-duration 10 --output-dir ./episodes
```

**Alternative - Basic Data Logging:**
You can also run the `data_logging_example()` function in the `control_interface.py` file:

```python
# In your control_interface.py file:
# Ensure data_logging_example() is uncommented in the __main__ block:

if __name__ == '__main__':
    # ...
    data_logging_example()
    # ...
```

**Execute the script:**
```bash
python3 control_interface.py
```

## Phase II: Autonomous Control (Writing Commands)

Once your policy is trained, you switch the RPi's role to an Active Writer by injecting its own control signals into the tapped lines, overriding the original receiver chip.

### 4.1 Principle of Writing

- The **RC transmitter must be OFF** during this phase to avoid signal conflicts
- The `set_control_commands()` function uses pigpio to actively generate the exact PWM output required for the actuators:
  - **Steering:** Sets the frequency to 47 Hz and outputs the required μs pulse width
  - **Throttle:** Sets the frequency to 985 Hz and outputs the required Duty Cycle (scaled 0→70%)

### 4.2 Execution

To test autonomous control, run the `autonomous_control_example()` function:

```python
# In your control_interface.py file:
# Ensure autonomous_control_example() is uncommented in the __main__ block:

if __name__ == '__main__':
    # ...
    # data_logging_example() # Must be commented out
    autonomous_control_example()
    # ...
```

**Execute the script:**
```bash
python3 control_interface.py
```

---

## Safety Reminders

- ⚠️ Always use the logic level converter to protect your Raspberry Pi
- ⚠️ Turn OFF the RC transmitter during autonomous control phase
- ⚠️ Ensure proper grounding between all components
- ⚠️ Test in a safe, controlled environment

## Troubleshooting

If you encounter issues:

1. Verify the pigpio daemon is running: `sudo pigpiod`
2. Check all wiring connections and ground references
3. Confirm signal parameters match your oscilloscope measurements
4. Ensure only one control method is active at a time (either data logging OR autonomous control)