# FTX Tracer Tr### 1.1 Tapped Signal Lines

Three essential control signals are tapped from the integrated ESC/Receiver board (FTX9731):

| Signal Name | Purpose / Function |
|-------------|-------------------|
| **PWM Drive (Throttle)** | Motor Control. High-frequency signal (‚âà985 Hz) controlled by Duty Cycle (0%‚Üí70%) |
| **PWM Servo (Steering)** | Steering Control. Standard RC signal (‚âà47 Hz) controlled by Pulse Width (1065Œºs‚Üí1959Œºs) |
| **GND (Ground)** | Common Reference. Must be connected to the Raspberry Pi's GND |n### 1.2 Logic Level Converter

‚ö†Ô∏è **Required for GPIO protection.** The car's 5V signals must be converted to 3.3V for safe Raspberry Pi operation.

- **HV Side:** Connect to car's PWM signals and ground
- **LV Side:** Connect to Raspberry Pi GPIO pins (BCM18 & 23) and ground
- **Ground:** Connect all ground references togetherct: Raspberry Pi Implementation ### 2.2 GPIO Pin Mapping

| Signal | BCM Pin |
|--------|---------|
| **Steering (PWM Servo)** | BCM 18 |
| **Throttle (PWM Drive)** | BCM 23 |his document outlines the hardware connections, verified signal parameters, and the software execution steps required to use your Raspberry Pi for both expert data capture and autonomous control of the FTX Tracer Truggy.

## Table of Contents

- [Hardware Overview and Signal Tapping](#hardware-overview-and-signal-tapping)
- [Raspberry Pi Software Setup](#raspberry-pi-software-setup)
- [Phase I: Data Logging](#phase-i-data-logging-reading-expert-commands)
- [Phase II: Autonomous Control](#phase-ii-autonomous-control-writing-commands)

## Hardware Overview and Signal Tapping

The core of this project relies on successfully intercepting the low-voltage control signals generated by the car's integrated ESC/Receiver board (FTX9731).

### 1.1 Tapped Signal Lines (The Three Critical Connections)

We identified three essential points on the integrated circuit, which you have successfully soldered:

| Signal Name | Physical Location | Purpose / Function |
|-------------|-------------------|-------------------|
| **PWM Drive (Throttle)** | Wire soldered to the main bus/trace near the large capacitor and MOSFETs | Motor Control. High-frequency signal (‚âà985 Hz) controlled by Duty Cycle (0%‚Üí70%) |
| **PWM Servo (Steering)** | Wire soldered near the servo driver chip (often close to the steering servo connector) | Steering Control. Standard RC signal (‚âà47 Hz) controlled by Pulse Width (1065Œºs‚Üí1959Œºs) |
| **GND (Ground)** | Tapped from the black wire/pin on the steering servo connector or a chassis point | Common Reference. Must be connected to the Raspberry Pi's GND |

### 1.2 Essential Safety Component: Logic Level Converter

‚ö†Ô∏è **This step is non-negotiable for protecting your Raspberry Pi.** The control signals from the car are likely 5V logic, while the Raspberry Pi's GPIO pins are only 3.3V-tolerant.

| Converter Side | Connects to... | Purpose |
|---------------|----------------|---------|
| **HV (High Voltage, 5V)** | ‚Üí Car's PWM Drive tap<br>‚Üí Car's PWM Servo tap | Signal conversion from 5V to 3.3V |
| **LV (Low Voltage, 3.3V)** | ‚Üí Raspberry Pi GPIO Pins (BCM18 & 23) | Signal Input/Output at RPi's safe voltage level |
| **GND** | ‚Üí Car's GND<br>‚Üí RPi's GND | Common ground reference |

### 1.3 Verified Signal Parameters

Your oscilloscope analysis provided the precise control values, which are hardcoded into the Python script for accurate recording and control:

| Parameter | Steering (PWM Servo) | Throttle (PWM Drive) |
|-----------|---------------------|---------------------|
| **Frequency** | 47 Hz | 985 Hz |
| **Neutral/Stop** | 1491Œºs (‚âà7.0% Duty) | 0% Duty Cycle |
| **Full Range** | 1065Œºs‚Üí1959Œºs | 0%‚Üí70% Duty Cycle |

## Raspberry Pi Software Setup and Prerequisites

Before running the control script, ensure your Raspberry Pi is configured for high-performance PWM access.

### 2.1 Install and Start the pigpio Daemon

The pigpio daemon runs in the background and handles the microsecond-accurate timing required to read and write PWM signals, bypassing the latency of the Python interpreter.

**Install the pigpio Library:**
```bash
sudo apt update
sudo apt install pigpio python3-pigpio
```

**Start the pigpio Service (Daemon):**
```bash
sudo pigpiod
```

> **Note:** This command must be executed every time you restart your RPi before running the control script.

### 2.2 GPIO Pin Mapping

The Python script uses the BCM (Broadcom) pin numbering scheme. Ensure your Level Converter's 3.3V outputs are wired to these physical pins:

| Signal | BCM Pin (in script) | Physical Pin |
|--------|-------------------|--------------|
| **Steering (PWM Servo)** | BCM 18 | Physical Pin 12 |
| **Throttle (PWM Drive)** | BCM 23 | Physical Pin 16 |

## Phase I: Data Logging (Reading Expert Commands)

This phase uses the `RCReader` class to passively "eavesdrop" on the PWM signals created by the human driver via the RC transmitter.

### 3.1 Principle of Reading

The `RCReader` class uses pigpio callbacks, which are hardware interrupts that trigger precisely when the signal changes (rising edge ‚ÜíHIGH, falling edge ‚ÜíLOW).

- **Steering:** We calculate the HIGH pulse duration in Œºs
- **Throttle:** We calculate the Duty Cycle (Pulse Width/Period) in percent
- **Normalization:** The `get_normalized_action()` method converts these raw values into ML-friendly actions (Steering ‚àà[‚àí1.0,1.0], Throttle ‚àà[0.0,1.0])

### 3.2 Execution

**Integrated Data Collection (Recommended):**
```bash
python3 src/record/integrated_data_collector.py --episode-duration 10 --output-dir ./episodes
```

**Alternative - Basic Data Logging:**
You can also run the `data_logging_example()` function in the `control_interface.py` file:

```python
# In your control_interface.py file:
# Ensure data_logging_example() is uncommented in the __main__ block:

if __name__ == '__main__':
    # ...
    data_logging_example()
    # ...
```

**Execute the script:**
```bash
python3 control_interface.py
```

## Phase II: Autonomous Control (Writing Commands)

Once your policy is trained, you switch the RPi's role to an Active Writer by injecting its own control signals into the tapped lines, overriding the original receiver chip.

### 4.1 Principle of Writing

- The **RC transmitter must be OFF** during this phase to avoid signal conflicts
- The `set_control_commands()` function uses pigpio to actively generate the exact PWM output required for the actuators:
  - **Steering:** Sets the frequency to 47 Hz and outputs the required Œºs pulse width
  - **Throttle:** Sets the frequency to 985 Hz and outputs the required Duty Cycle (scaled 0‚Üí70%)

### 4.2 Execution

To test autonomous control, run the `autonomous_control_example()` function:

```python
# In your control_interface.py file:
# Ensure autonomous_control_example() is uncommented in the __main__ block:

if __name__ == '__main__':
    # ...
    # data_logging_example() # Must be commented out
    autonomous_control_example()
    # ...
```

**Execute the script:**
```bash
python3 control_interface.py
```

## Network Testing and Remote Inference Setup

For remote inference (running ML models on your laptop while the Pi captures data), you need to test and verify network communication between your Raspberry Pi and laptop.

### 5.1 Network Test Overview

The network testing setup allows you to:
- Verify reliable communication between Pi and laptop
- Test camera frame transmission at 640x480 resolution
- Validate image encoding/decoding pipeline
- Ensure robust data transfer for real-time inference

### 5.2 Running Network Tests

**Step 1: Start the test server on your laptop:**
```bash
# On your laptop
cd /path/to/your/project/src/network
python3 test_server_laptop_fixed.py --port 8889
```

The server will display your laptop's IP address (e.g., `192.168.1.33`).

**Step 2: Run the test client on your Raspberry Pi:**
```bash
# On your Raspberry Pi
cd /home/raspberrypi/EDTH2025/quantum-tracer-il/src/network
python3 test_client_fixed_v2.py
```

Enter your laptop's IP address when prompted.

### 5.3 Test Sequence

The client performs three tests automatically:

1. **Basic Connection Test**: Verifies socket communication with JSON messages
2. **Camera Test**: Confirms camera capture works (640x480 resolution)
3. **Frame Sending Test**: Tests large image data transfer (~33KB per frame)

### 5.4 Expected Results

**Successful test output:**
```
‚úÖ Basic connection test PASSED
‚úÖ Camera test PASSED  
‚úÖ Frame sending test PASSED
üéâ ALL TESTS PASSED! Network communication is working.
```

**Network specifications:**
- **Image resolution**: 640x480 (VGA)
- **Compression**: JPEG quality 60%
- **Frame size**: ~33KB per frame
- **Transfer reliability**: Robust with 1MB socket buffers and 30s timeouts

### 5.5 Remote Inference Server

Once network tests pass, you can run the full remote inference system:

**On laptop (inference server):**
```bash
python3 src/network/remote_inference_server.py --dummy-model --port 8888
```

**On Raspberry Pi (with remote inference enabled):**
```bash
python3 src/record/integrated_data_collector.py --remote-inference --server-ip 192.168.1.33
```

---

## Safety Reminders

- ‚ö†Ô∏è Always use the logic level converter to protect your Raspberry Pi
- ‚ö†Ô∏è Turn OFF the RC transmitter during autonomous control phase
- ‚ö†Ô∏è Ensure proper grounding between all components
- ‚ö†Ô∏è Test in a safe, controlled environment
- ‚ö†Ô∏è Verify network connectivity before running remote inference

## Troubleshooting

If you encounter issues:

1. Verify the pigpio daemon is running: `sudo pigpiod`
2. Check all wiring connections and ground references
3. Confirm signal parameters match your oscilloscope measurements
4. Ensure only one control method is active at a time (either data logging OR autonomous control)